# Ruby


## Rubyに関する基礎知識

* 識別子と予約語　
以下の予約語は識別子として使うことができない

* putsメソッド、printメソッド、pメソッド、ppメソッド




その他

* 定数はメソッド内で定義できない
* foo(*arr)  引数に配列を渡す
* foo(**hash)  引数にハッシュ(キーワード引数)を渡す

参照

* a.equal?(b)  オブジェクトIDが一致するか
* a.eql?(b)  オブジェクトの値が一致するか
※ 1.eql?(1.0) => false



## 演算子

&&や||の戻り値と評価を終了するタイミング
* 式の左側から評価
* 式全体の真または偽が確定すると式の評価を終了
* 最後に評価した式の値を返す

論理演算子の応用
* item = ary&.first  arrがnilでない時のみ firstメソッドを呼び出す
* var || = 1  varがnilの時のみ1を代入

優先順位
* (*)(/)(%) > (+) > (-) > (&&) > (||) > (==) > (=) 


## 数列

基数指示子を用いた整数リテラル
- 0b○○  2進数
- 0d○○  10進数
- 0o○○  8進数
- 0x○○  16進数

四則演算
* x.div(y)  割算
* x.quo(y)  割算 ※Rationalに変換
* x.modulo(y)  余り
* x.remainder(y)  余り※xの符号に一致
* x.divmod(y)  割引  ※商と余りを配列で返す

変換
* to_f  Flootに変換
* to_r  Rationに変換
* to_i  小数切り捨て
* round  小数四捨五入
* floor  小数切り捨て

ランダム値
* Random.rand(n)  0〜nまでの整数をランダムで1つ生成
* secureRandom.base64  英数字記号を生成


## 配列

配列作成
- Array.new(x, y)  xが要素数、yが格納される値  ※Array.new(x){y}でも可
- Array[a]
- %w(a)または%w|a|
- %i(a)  ※要素がシンボルになる
- to_a  ※ハッシュ、範囲オブジェクトを配列に変換

要素の参照
* a.at(n)  n番目の要素を取り出す
    * a.slice(n)
* a.values_at(n1, n2, …)  とびとびに要素を取り出す&配列を返す

要素の変更、追加、削除
* a.push(item)  末尾に挿入
* a.pop  末尾を取り除く※破壊的
* a.unshift(item)  先頭に挿入
* a.shift  先頭を取り除く※破壊的
* a.concat(b)  連結  ※破壊的
* a.compact  nilを削除 ※非破壊的
* a.delete(x)  要素xを削除  ※破壊的
* a.delete_at(x)  添字x番目を削除  ※破壊的
* a.delete_if  {|item| …}  aからitemを取り除く  ※破壊的
    * a.reject!
    
ブロックを使う配列メソッド
* a.collect {|item|…}  別の要素に置き換える
    * a.map {|item| …}
* a.detect {|item| …}  aからitemと一致した先頭の要素を返す
    * a.find {|item| …}
* a.select {|item| …}  aからitemと一致した要素を全て返す
    * a.find_all {|item| …}
* a.each_slice(n)  aからn個ずつブロックに渡す
* a.partition {|item| …}  真と偽に分けて別々の配列を作成
* a.inject(x) {|i, item| …}  要素を注入し処理(合算)
※ x(初期値)を入れる→ iに代入
※ xを省略 → aの先頭をiに代入
※ xに演算子を入れる → 指定した演算でaを計算(ブロックNG)
* a.sum(x) 要素の合計を算出  ※引数で0以外の初期値を指定することも可

その他
* a.fill(value)  valueに置き換える
* a.flatten  平坦化  ※非破壊的
* a.zip(b)  2つの配列をつなげる
* a.product([b])  レシーバの配列と引数の配列それぞれから要素を1 個ずつとって新しい配列を作成
* a.join(x)  配列の要素を連結して1つの文字列にする
* a.chars(str)  文字列を1文字ずつ配列の要素に分解する
* *[a]  配列を展開
* *”a”  配列として代入


## 文字列

文字列作成
- %Q  式展開あり
- %q  式展開なし
- %のみでも可

ヒアドキュメント作成 
* << “終了の記号” 
※ 末尾の区切文字は行頭にする
※ 終了記号を””で囲むと式展開
※ 空白も認識される
※ <<-  区切文字行頭の空白が無視
※<<~  すべての行の空白を無視

要素の変更、追加、削除
* s.chop  末尾を削除
* s.chomp  末尾を削除(改行文字のみ)
* s.delete(str)   文字列strを削除  ※非破壊的
* s.strip  先頭末尾の空白|改行削除  ※非破壊的
* s.swapcase  大文字⇄小文字を変換
* s.tr(a, b)  aと一致した文字をbに置き換える

その他
* s.index(str)  sから一致した文字列の先頭添字を返す
    * s.rindex(str)


## シンボル

シンボル作成
- to_s  文字列をシンボルに変換
- %s(x)
- %i(x)  ※シンボル値の配列作成


## ハッシュ

ハッシュ作成
- Hash.new(a)  デフォルト値aを設定
- Hash[]  ※空はNG
- to_h  ※配列オブジェクトに有効

要素の参照
* h.fetch(a)  キーaに対応する値bを取得
* h.keys  登録されたkey取得
* h.values  登録されたvalue取得
* h.values_at(key)  とびとびでキーに対応する要素を取り出す
* h.key?(key)  keyがあればtrue
    * h.has_key?(key)
    * h.include?(key)
    * h.member?(key)
* h.value?(value)  valueがあればtrue
    * h.has_value?(value)
    
要素の変更、追加、削除
* h.store(a,b)  キーaと値bを登録
* h.delete(key)  キーを削除  ※破壊的
* h.clear  ハッシュを空にする  ※破壊的
* h1.merge(h2)  2つのハッシュを合体　※非破壊的
    * h1.update(h2)  ※破壊的


## 正規表現

* .  任意の1文字にマッチ
* \s  改行や空白にマッチ
* \w  英数字にマッチ
* \A  文字列の先頭にマッチ
* \z  文字列の末尾にマッチ
* [^○]  ○以外の文字にマッチ
* scan  正規表現で()を使うと、マッチした部分を配列で返す
* i  英字大文字小文字を区別しない
* scan(\(n)\)  正規表現内で()がある場合はマッチ内容を配列で返す



　正規表現とは、ある一定の規則で並んでいる文字列を検出するための技術のことです。
　正規表現オブジェクトは次のようにスラッシュでパターンを囲んで作成します（正規表現リテラル）

例）  /正規表現/

￼
* []・・・[]内のいずれか1文字を表すメタ文字
* {数字}・・・「直前のパターンを数字の分だけ繰り返す」メタ文字
* +・・・「直前の文字が1回以上連続する」ということを意味するメタ文字
* ＊・・・「直前の文字が0個以上」を表すメタ文字
* ?・・・「直前の文字を0もしくは1回繰り返す」メタ文字
* \w・・・「アルファベットの大文字or小文字、または数字、またはアンダースコアのいずれか1文字」の意味
* \d・・・「10進数の数字にいずれか1文字」の意味


正規表現の文法
　文字列と正規表現のマッチを試みる方法はいくつかあります。その1つが「=~」です。=~を使うと、正規表現がマッチした場合は文字列中の最初にマッチした位置（0以上の数値）が返り、マッチしなかった場合はnilが返ります。


キャプチャ機能
　丸括弧()で括ってグループ化したパターンに対してマッチングを行うと、マッチした文字列を抜き出して後で使うことができるようになります。

● MatchData
* matchメソッドによるパターンマッチの場合、MatchDataオブジェクトが返ります。マッチしない場合はnilが返ります。
* MatchDataは[]を使って正規表現の処理結果を取得できます。 
例）
 text = '私の誕生日は1977年7月17日です'
 m = /(\d+)年(\d+)月(\d+)日/.match(text)

　 # マッチした部分全体を取得する
 m[0]    #=> "1977年7月17日"

　 # キャプチャの1番目を取得する
 m[1]    #=> "1977"

　 # キャプチャの2番目から2個取得する
 m[2, 2] #=> ["7", "17"]

　 # 最後のキャプチャを取得する
 m[-1]   #=> "17"

● キャプチャに名前を付ける
* キャプチャには(?<name>)というメタ文字を使って名前を付けることができます。
例）  (?<year>\d+)年(?<month>\d+)月(?<day>\d+)日
* 左辺に正規表現リテラルを、右辺に文字列を置いて=~演算子を使うと、キャプチャの名前がそのままローカル変数に割り当てられるのです。

● 組み込み変数でマッチの結果を取得する
　$で始まる特殊な変数（組み込み変数）が存在します。=~演算子やmatchメソッドを使うと、組み込み変数にマッチした結果が代入されます。

例）# マッチした部分全体を取得する
 $& #=> "1977年7月17日"

例）# 1番目～3番目のキャプチャを取得する
 $1 #=> "1977"
 $2 #=> "7"
 $3 #=> "17"

例） # 最後のキャプチャ文字列を取得する
 $+ #=> "17"

正規表現と組み合わせると便利なStringクラスのメソッド 

● scanメソッド
　引数で渡した正規表現にマッチする部分を配列に入れて返します。

● []、slice、slice!メソッド
　正規表現を渡すと、文字列から正規表現にマッチした部分を抜き出します。
※ マッチする部分が複数ある場合は、最初にマッチした文字列が返ります
※ キャプチャを使うと第2引数で何番目のキャプチャを取得するか指定できます。
例）
text = '誕生日は1977年7月17日です'
　 # 第2引数を指定して3番目のキャプチャを取得する
text[/(\d+)年(\d+)月(\d+)日/, 3] #=> "17"

● splitメソッド
　正規表現を渡すと、マッチした文字列を区切り文字にして文字列を分解し、配列として返します。

● gsub、gsub!メソッド
　第1引数の正規表現にマッチした文字列を第2引数の文字列で置き換えます。
※ 第2引数にハッシュを渡して、変換のルールを指定することもできます。

正規表現オブジェクトを作成するさまざまな方法

1. Regexp.newの引数にパターンの文字列を渡す方法
2. %rを使う方法（%記法）

正規表現オブジェクト作成時のオプション

● mオプション
　任意の文字を表すドット（.）が改行文字にもマッチするようになります。

● xオプション
　空白文字（半角スペースや改行文字）が無視される

Regexp.last_matchでマッチの結果を取得する
　=~演算子などで最後にマッチした結果をMatchDataオブジェクトとして取得できます。



## 例外処理

* rescue  例外発生時の処理
※ 例外クラスを指定しない場合はstandarderrorとサブクラスを補足
* rescue => e  例外情報取得
    * $!  最後に発生した例外情報取得
    * $@  最後に発生した例外情報取得
* ensure~end  例外有無に関わらず実行される処理
* retry  began節からやり直し
* raise  意図的に例外発生
    * raise message RuntimeError&メッセージを発生
    * raise Exception  指定した例外クラスを発生
    * raise Exception, message  指定した例外クラスとメッセージを発生
    
例外クラス
- RuntimeError  特定の例外クラスには該当しないエラー
- syntax error  構文エラー
- NameError/NoMethodError  変数またはメソッドが存在しない  ※NameErrorがスーパークラス
- TypeError  別のオブジェクトが渡されている
- ZeroDivisionError  整数を0で割る


## IO

* STDIN  組み込み定数
* $stdin
* STDOUT  組み込み定数
* $stdout
* io = File.open(file[, mode[, perm]][, opt]
    * r  読み込み専用
    * r+  読み込み/書き込み用
    * w  書き込み専用(新規作成)
    * w+  読み込み/書き込み用
    * a  追加書き込み用
    * a+  読み込み/追加書き込み
* file.close
* File.read(file,[, length[, offset]]  lengthは読み込むサイズ、offsetには先頭何バイト目から読み込むか
* File.binread(file,[, length[, offset]]  
* File.write(file, date[, length[, offset]]  
* io.gets  1行ずつ読み込む
    * io.each
    * io.each_line
* io.readline  改行区切りで配列として返す
* io.each_char 1文字ずつ読み込む
* io.getc 1文字だけ読み込む
* io.read(size)  長さを指定して読み込む
* io.puts  
* io.pos  ファイルポインタの現在位置取得
* io.seek(offset, whence)  ファイルポインタを移動する
    * SEEK_SET  offsetの位置に移動する
    * SEEK_CUR  offsetを現在の相対位置と見なし移動する
    * SEEK_END  offsetをファイル末尾からの相対位置とし移動する
* io.rewind  ポインタを先頭に戻す


## File

* File.rename(“before”, “after”) ファイル名変更/ファイル移動  ※Fileクラスのみ
* File.delete(file) ファイル削除
    * File.unlink(file)
* Dir.pwd  ※Dirクラスのみ
* Dir.chdir(dir)  ※Dirクラスのみ
* Dir.open(path)  フォルダ内容を読む
* Dir.close
* dir.read
* Dir.mkdir(path)  新しいフォルダを作成
* Dir.rmdir(path)  フォルダを削除
    * Dir.delete
* Dir.home
* File.chmod(mode, path)  ファイルpathの許可モード変更
* File.chown(owner, group, path)ファイルpathの所有者を変更
* File.basename(path)  拡張子を除いたファイル名を取得
* File.dirname(path)  ディレクトリ名を取得
* File.extname(path)  拡張子を取得
* File.split(path)  ディレクトリ名とファイル名に分解→配列で返す
* File.join(name1, name2…)

* Time.new = Time.now
* t.year
* t.month
* t.day
* t.strftime(format) = t.to_s
    * %Y  西暦4桁
    * %y  西暦下2桁
    * %M  分
    * %m  月を表す数字
    * %D  %m/%d/%yと同じ
    * %x  %Dと同じ
    * %F  %Y-%m-%dと同じ
* Time.parse(str)  文字列から時間に変化する
    * Time.strptime(str,format)
* Date.parse(str)  文字列から時間に変化する
    * Date.strptime(str, format)
* to_time
* to_date
