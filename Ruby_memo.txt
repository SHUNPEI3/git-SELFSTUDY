# Ruby


## Rubyに関する基礎知識

  識別子と予約語
  以下の予約語は識別子として使うことができない

  putsメソッド、printメソッド、pメソッド、ppメソッド

  その他
  * 定数はメソッド内で定義できない
  * foo(*arr)  引数に配列を渡す
  * foo(**hash)  引数にハッシュ(キーワード引数)を渡す

  参照

  * a.equal?(b)  オブジェクトIDが一致するか
  * a.eql?(b)  オブジェクトの値が一致するか
    ※ 1.eql?(1.0) => false


## 演算子

  &&や||の戻り値と評価を終了するタイミング
  * 式の左側から評価
  * 式全体の真または偽が確定すると式の評価を終了
  * 最後に評価した式の値を返す

  論理演算子の応用
  * item = ary&.first  arrがnilでない時のみ firstメソッドを呼び出す
  * var || = 1  varがnilの時のみ1を代入

  優先順位
  * (*)(/)(%) > (+) > (-) > (&&) > (||) > (==) > (=)


## 数列

  基数指示子を用いた整数リテラル
  - 0b○○  2進数
  - 0d○○  10進数
  - 0o○○  8進数
  - 0x○○  16進数

  四則演算
  - x.div(y)  割算
  - x.quo(y)  割算 ※Rationalに変換
  - x.modulo(y)  余り
  - x.remainder(y)  余り※xの符号に一致
  - x.divmod(y)  割引  ※商と余りを配列で返す

  変換
  - to_f  Flootに変換
  - to_r  Rationに変換
  - to_i  小数切り捨て
  - round  小数四捨五入
  - floor  小数切り捨て

  ランダム値
  - Random.rand(n)  0〜nまでの整数をランダムで1つ生成
  - secureRandom.base64  英数字記号を生成


## 配列

  配列作成
  - Array.new(x, y)  xが要素数、yが格納される値  ※Array.new(x){y}でも可
  - Array[a]
  - %w(a)または%w|a|
  - %i(a)  ※要素がシンボルになる
  - to_a  ※ハッシュ、範囲オブジェクトを配列に変換

  要素の参照
  - a.at(n)  n番目の要素を取り出す
    = a.slice(n)
  - a.values_at(n1, n2, …)  とびとびに要素を取り出す&配列を返す

  要素の変更、追加、削除
  - a.push(item)  末尾に挿入
  - a.pop  末尾を取り除く※破壊的
  - a.unshift(item)  先頭に挿入
  - a.shift  先頭を取り除く※破壊的
  - a.concat(b)  連結  ※破壊的
  - a.compact  nilを削除 ※非破壊的
  - a.delete(x)  要素xを削除  ※破壊的
  - a.delete_at(x)  添字x番目を削除  ※破壊的
  - a.delete_if  {|item| …}  aからitemを取り除く  ※破壊的
    = a.reject!

  ブロックを使う配列メソッド
  - a.collect {|item|…}  別の要素に置き換える
    = a.map {|item| …}
  - a.detect {|item| …}  aからitemと一致した先頭の要素を返す
    = a.find {|item| …}
  - a.select {|item| …}  aからitemと一致した要素を全て返す
    = a.find_all {|item| …}
  - a.each_slice(n)  aからn個ずつブロックに渡す
  - a.partition {|item| …}  真と偽に分けて別々の配列を作成
  - a.inject(x) {|i, item| …}  要素を注入し処理(合算)
    ※ x(初期値)を入れる→ iに代入
    ※ xを省略 → aの先頭をiに代入
    ※ xに演算子を入れる → 指定した演算でaを計算(ブロックNG)
  - a.sum(x) 要素の合計を算出  ※引数で0以外の初期値を指定することも可

  その他
  - a.fill(value)  valueに置き換える
  - a.flatten  平坦化  ※非破壊的
  - a.zip(b)  2つの配列をつなげる
  - a.product([b])  レシーバの配列と引数の配列それぞれから要素を1 個ずつとって新しい配列を作成
  - a.join(x)  配列の要素を連結して1つの文字列にする
  - a.chars(str)  文字列を1文字ずつ配列の要素に分解する
  - *[a]  配列を展開
  - *”a”  配列として代入


## 文字列

  文字列作成
  - %Q  式展開あり
  - %q  式展開なし
  - %のみでも可

  ヒアドキュメント作成
  - << “終了の記号”
    ※ 末尾の区切文字は行頭にする
    ※ 終了記号を””で囲むと式展開
    ※ 空白も認識される
    ※ <<-  区切文字行頭の空白が無視
    ※ <<~  すべての行の空白を無視

  要素の変更、追加、削除
  - s.chop  末尾を削除
  - s.chomp  末尾を削除(改行文字のみ)
  - s.delete(str)   文字列strを削除  ※非破壊的
  - s.strip  先頭末尾の空白|改行削除  ※非破壊的
  - s.swapcase  大文字⇄小文字を変換
  - s.tr(a, b)  aと一致した文字をbに置き換える

  その他
  - s.index(str)  sから一致した文字列の先頭添字を返す
    = s.rindex(str)


## シンボル

  シンボル作成
  - to_s  文字列をシンボルに変換
  - %s(x)
  - %i(x)  ※シンボル値の配列作成


## ハッシュ

  ハッシュ作成
  - Hash.new(a)  デフォルト値aを設定
  - Hash[]  ※空はNG
  - to_h  ※配列オブジェクトに有効

  要素の参照
  - h.fetch(a)  キーaに対応する値bを取得
  - h.keys  登録されたkey取得
  - h.values  登録されたvalue取得
  - h.values_at(key)  とびとびでキーに対応する要素を取り出す
  - h.key?(key)  keyがあればtrue
    = h.has_key?(key)
    = h.include?(key)
    = h.member?(key)
  - h.value?(value)  valueがあればtrue
    = h.has_value?(value)

  要素の変更、追加、削除
  - h.store(a,b)  キーaと値bを登録
  - h.delete(key)  キーを削除  ※破壊的
  - h.clear  ハッシュを空にする  ※破壊的
  - h1.merge(h2)  2つのハッシュを合体　※非破壊的
    = h1.update(h2)  ※破壊的


## 正規表現

  - .  任意の1文字にマッチ
  - +・・・「直前の文字が1回以上連続する」ということを意味するメタ文字
  - ＊・・・「直前の文字が0個以上」を表すメタ文字
  - \s  改行や空白にマッチ
  - \A  文字列の先頭にマッチ
  - \z  文字列の末尾にマッチ
  - \w・・・「アルファベットの大文字or小文字、または数字、またはアンダースコアのいずれか1文字」の意味
  - \d・・・「10進数の数字にいずれか1文字」の意味
  - []・・・[]内のいずれか1文字を表すメタ文字
  - [^○]  ○以外の文字にマッチ
  - i  英字大文字小文字を区別しない
  - scan(\(n)\)  正規表現内で()がある場合はマッチ内容を配列で返す
  - {数字}・・・「直前のパターンを数字の分だけ繰り返す」メタ文字
  - ?・・・「直前の文字を0もしくは1回繰り返す」メタ文字

  正規表現の文法
    *文字列と正規表現のマッチを試みる方法はいくつかあります。その1つが「=~」です。=~を使うと、正規表現がマッチした場合は文字列中の最初にマッチした位置（0以上の数値）が返り、マッチしなかった場合はnilが返ります。


  キャプチャ機能
    *丸括弧()で括ってグループ化したパターンに対してマッチングを行うと、マッチした文字列を抜き出して後で使うことができるようになります。

  MatchData
    * matchメソッドによるパターンマッチの場合、MatchDataオブジェクトが返ります。マッチしない場合はnilが返ります。
    * MatchDataは[]を使って正規表現の処理結果を取得できます。
  例）
    text = '私の誕生日は1977年7月17日です'
    m = /(\d+)年(\d+)月(\d+)日/.match(text)

    # マッチした部分全体を取得する
      m[0]    #=> "1977年7月17日"

    # キャプチャの1番目を取得する
      m[1]    #=> "1977"

    # キャプチャの2番目から2個取得する
      m[2, 2] #=> ["7", "17"]

    # 最後のキャプチャを取得する
      m[-1]   #=> "17"

  キャプチャに名前を付ける
    * キャプチャには(?<name>)というメタ文字を使って名前を付けることができます。
    例）  (?<year>\d+)年(?<month>\d+)月(?<day>\d+)日
    * 左辺に正規表現リテラルを、右辺に文字列を置いて=~演算子を使うと、キャプチャの名前がそのままローカル変数に割り当てられるのです。

    ● 組み込み変数でマッチの結果を取得する
    　$で始まる特殊な変数（組み込み変数）が存在します。=~演算子やmatchメソッドを使うと、組み込み変数にマッチした結果が代入されます。

    例）# マッチした部分全体を取得する
      $& #=> "1977年7月17日"

    例）# 1番目～3番目のキャプチャを取得する
      $1 #=> "1977"
      $2 #=> "7"
      $3 #=> "17"

    例） # 最後のキャプチャ文字列を取得する
      $+ #=> "17"

  正規表現と組み合わせると便利なStringクラスのメソッド
  -  scanメソッド
    引数で渡した正規表現にマッチする部分を配列に入れて返します。

  -  []、slice、slice!メソッド
  　正規表現を渡すと、文字列から正規表現にマッチした部分を抜き出します。
    ※ マッチする部分が複数ある場合は、最初にマッチした文字列が返ります
    ※ キャプチャを使うと第2引数で何番目のキャプチャを取得するか指定できます。
    例）
      text = '誕生日は1977年7月17日です'
      # 第2引数を指定して3番目のキャプチャを取得する
      text[/(\d+)年(\d+)月(\d+)日/, 3] #=> "17"

  -  splitメソッド
    正規表現を渡すと、マッチした文字列を区切り文字にして文字列を分解し、配列として返します。

  -  gsub、gsub!メソッド
    第1引数の正規表現にマッチした文字列を第2引数の文字列で置き換えます。
    ※ 第2引数にハッシュを渡して、変換のルールを指定することもできます。

  正規表現オブジェクトを作成するさまざまな方法
    1. Regexp.newの引数にパターンの文字列を渡す方法
    2. %rを使う方法（%記法）

  正規表現オブジェクト作成時のオプション

  -  mオプション
　  任意の文字を表すドット（.）が改行文字にもマッチするようになります。

  -  xオプション
　  空白文字（半角スペースや改行文字）が無視される

  Regexp.last_matchでマッチの結果を取得する
　  =~演算子などで最後にマッチした結果をMatchDataオブジェクトとして取得できます。


## 例外処理

  例外を捕捉して処理を続行する場合
    何らかの理由で例外が発生してもプログラムを続行したい場合は、例外処理を明示的に書くことでプログラムを続行させることが可能。
  例）
    begin
      # 例外が起きうる処理
    rescue
      # 例外が発生した場合の処理
    end

  - rescue  例外発生時の処理
    ※ 例外クラスを指定しない場合はstandarderrorとサブクラスを補足

  例外オブジェクトから情報を取得する
　  Rubyでは発生した例外自身もオブジェクトになっています。そのため例外オブジェクトのメソッドを呼び出すことで、発生した例外に関する情報を取得することができます。

  クラスを指定して捕捉する例外を限定する
　  例外には多くの種類があり、その種類ごとにクラスが異なります。次のような構文を使って例外のクラスを指定すると、例外オブジェクトのクラスが一致した場合のみ、例外を捕捉することができます。

  - rescue => e  例外情報取得
    * $!  最後に発生した例外情報取得
    * $@  最後に発生した例外情報取得

  - messageメソッド
    例外発生時のエラーメッセージを返します。

  - backtraceメソッド
　  バックトレース情報（つまりメソッドの呼び出し履歴）を配列にして返します。

  例外発生時にもう一度処理をやりなおすretry
　  ネットワークエラーのように一時的に発生している問題が例外の原因であれば、何度かやりなおすことで正常に実行できる可能性があります。そんな場合はrescue節でretry文を実行すると、begin節の最初からやりなおすことができます。

  - retry  began節からやり直し

  意図的に例外を発生させる
　  コードの中で意図的に例外を発生させることができます。例外を発生させる場合はraiseメソッドを使います。

  - raiseメソッド
　  文字列を渡すと、その文字列がエラーメッセージになる。
    ※ raiseメソッドに文字列だけを渡したときはRuntimeErrorクラスの例外が発生します。

  - raise  意図的に例外発生
    * raise message RuntimeError&メッセージを発生
    * raise Exception  指定した例外クラスを発生
    * raise Exception, message  指定した例外クラスとメッセージを発生

  例外クラス
  - RuntimeError  特定の例外クラスには該当しないエラー
  - syntax error  構文エラー
  - NameError/NoMethodError  変数またはメソッドが存在しない  ※NameErrorがスーパークラス
  - TypeError  別のオブジェクトが渡されている
  - ZeroDivisionError  整数を0で割る

  ● ensure
　  例外処理を入れた場合、例外が発生してもしなくても必ず実行したい処理が出てくる場合があります。そんな場合は例外処理にensure節を加えることで必ず実行される処理を書くことができます。

  ● $!と$@に格納される例外情報
　  Rubyでは最後に発生した例外は組み込み変数の$!に格納されます。また、バックトレース情報は$@に格納されます。

## IO

  - STDIN  組み込み定数
  - $stdin
  - STDOUT  組み込み定数
  - $stdout
  - io = File.open(file[, mode[, perm]][, opt]
    * r  読み込み専用
    * r+  読み込み/書き込み用
    * w  書き込み専用(新規作成)
    * w+  読み込み/書き込み用
    * a  追加書き込み用
    * a+  読み込み/追加書き込み
  - file.close
  - File.read(file,[, length[, offset]]  lengthは読み込むサイズ、offsetには先頭何バイト目から読み込むか
  - File.binread(file,[, length[, offset]]
  - File.write(file, date[, length[, offset]]
  - io.gets  1行ずつ読み込む
    * io.each
    * io.each_line
  - io.readline  改行区切りで配列として返す
  - io.each_char 1文字ずつ読み込む
  - io.getc 1文字だけ読み込む
  - io.read(size)  長さを指定して読み込む
  - io.puts
  - io.pos  ファイルポインタの現在位置取得
  - io.seek(offset, whence)  ファイルポインタを移動する
    * SEEK_SET  offsetの位置に移動する
    * SEEK_CUR  offsetを現在の相対位置と見なし移動する
    * SEEK_END  offsetをファイル末尾からの相対位置とし移動する
  - io.rewind  ポインタを先頭に戻す


## File

  - File.rename(“before”, “after”) ファイル名変更/ファイル移動  ※Fileクラスのみ
  - File.delete(file) ファイル削除
    * File.unlink(file)
  - Dir.pwd  ※Dirクラスのみ
  - Dir.chdir(dir)  ※Dirクラスのみ
  - Dir.open(path)  フォルダ内容を読む
  - Dir.close
  - dir.read
  - Dir.mkdir(path)  新しいフォルダを作成
  - Dir.rmdir(path)  フォルダを削除
    * Dir.delete
  - Dir.home
  - File.chmod(mode, path)  ファイルpathの許可モード変更
  - File.chown(owner, group, path)ファイルpathの所有者を変更
  - File.basename(path)  拡張子を除いたファイル名を取得
  - File.dirname(path)  ディレクトリ名を取得
  - File.extname(path)  拡張子を取得
  - File.split(path)  ディレクトリ名とファイル名に分解→配列で返す
  - File.join(name1, name2…)

  - Time.new = Time.now
  - t.year
  - t.month
  - t.day
  - t.strftime(format) = t.to_s
    * %Y  西暦4桁
    * %y  西暦下2桁
    * %M  分
    * %m  月を表す数字
    * %D  %m/%d/%yと同じ
    * %x  %Dと同じ
    * %F  %Y-%m-%dと同じ
  - Time.parse(str)  文字列から時間に変化する
    * Time.strptime(str,format)
  - Date.parse(str)  文字列から時間に変化する
    * Date.strptime(str, format)
  - to_time
  - to_date


## クラス

  initializeメソッド
　  クラスからオブジェクトを作成する場合はnewメソッドを使います。このときに呼ばれるのがinitializeメソッドです。initializeメソッドに引数を付けると、newメソッドを呼ぶときにも引数が必要になります。

  インスタンス変数とアクセサメソッド

    インスタンス変数
      インスタンス変数とは同じインスタンス（同じオブジェクト）の内部で共有される変数です。インスタンス変数はクラスの外部から参照することができません

      nameメソッドのように値を読み出すメソッドを「ゲッターメソッド」、name=メソッドのように値を書き込むメソッドを「セッターメソッド」と呼びます。
      また、ゲッターメソッドとセッターメソッドを総称して、「アクセサメソッド」と呼びます。

      ● 単純にインスタンス変数の内容を外部から読み書きするのであれば、attr_accessorというメソッドを使ってアクセスメソッドの定義を省略することができます
      例）attr_accessor :name

      ● インスタンス変数の内容を読み取り専用にしたい場合はattr_accessorの代わりにattr_readerメソッドを使います
      例）attr_reader :name

  定数
　  定数はクラスの外部から直接参照することも可能です。クラスの外部から定数を参照する場合は次のような構文を使います。

    クラス名::定数名


  Rubyのクラスメソッドとインスタンスメソッドの違い

  ■ クラスメソッド・・・クラスオブジェクトから実行可能なメソッド

  class Hoge
    def self.hoge または  class << self
      puts "hoge"
    end
  end
  Hoge.hoge # => hoge
  ※ クラスメソッドを使う場合、クラス直下のメソッドにself.を設定する

  ■ インスタンスメソッド・・・インスタンスオブジェクトから実行可能なメソッド

  class Hoge
    def hoge
      puts "hoge"
    end
  end
  Hoge.new.hoge # => hoge

  1. インスタンスメソッドからインスタンスメソッドを呼び出す
　  インスタンスメソッドの中からインスタンスメソッドを呼び出すときはレシーバを省略できます

  class User
    def greeting
      ①User.name        # クラスを明示する
      ②self.class.name  # self.class はUserとなる
      ③class.name       # selfは省略できる
    end

    def self.name
      '太郎'
    end
  end

  2. クラスメソッドからインスタンスメソッドを呼び出す
　  インスタンスメソッドを呼び出すにはレシーバをインスタンスにする必要があるので以下のようになります。

  class User
    def self.greeting
      ①User.new.name # クラスのインスタンスを生成してからnameメソッドを呼び出す
      ②self.new.name  # Userをselfにした
      ③new.name          # selfは省略できる
    end

    def name
      '太郎'
    end
  end

  3. クラスメソッドからクラスメソッドを呼び出す
　  クラスメソッド内のselfはクラス自身なのでレシーバを省略して普通にメソッドを呼び出せます。


  クラスの継承

    DVDクラスがProductクラスを継承するとき、ProductクラスのことをDVDクラスの「スーパークラス（または親クラス）」と呼びます。逆にProductクラスから見ると、DVDクラスはProductクラスの「サブクラス（または子クラス）」と呼びます。
    サブクラスはスーパークラスの性質を特化したもので、反対にスーパークラスはサブクラスの性質を汎化したものである、という関係もなりたちます。
    クラスの継承が適切かどうかを判断する方法の1つは、 「サブクラスはスーパークラスの一種である（サブクラス is a スーパークラス）」 と声に出して読んだときに違和感がないか確かめることです。

    ●オブジェクトのクラスを確認する方法
      1. user.class #=> User
      2. user.instance_of?(User)   #=> true

    ●継承関係（is-a関係にあるかどうか）を含めて確認する方法
      - user.is_a?(Object)        #=> true

    ●superでスーパークラスのメソッドを呼び出す
    　superを使うとスーパークラスの同名メソッドを呼び出すことができます。
　    スーパークラスとサブクラスで引数の数が同じだった場合は、引数なしのsuperを呼ぶだけで自分に渡された引数をすべてスーパークラスに引き渡すことができます

    ●メソッドのオーバーライド
    　サブクラスではスーパークラスと同名のメソッドを定義することで、スーパークラスの処理を上書きすることができます。


  特異メソッド
    特定のオブジェクトにだけ紐付くメソッドのことを特異メソッドと呼びます。数値（IntegerとFloat）やシンボルなど、特異メソッドを定義できないオブジェクトも存在します。
    ※クラスメソッドは特異メソッドの一種です。

  ダックタイピング
    オブジェクトのクラスが何であろうとそのメソッドが呼び出せれば良しとするプログラミングスタイルのことを「ダックタイピング（duck typing）」と呼びます。


## モジュール

* モジュールからインスタンスを作成することはできない。
* ほかのモジュールやクラスを継承することはできない。

モジュールをクラスにincludeする
　モジュールをクラスにincludeして機能を追加することをミックスインと言います。また、1つのクラスに複数のモジュールをミックスインすることもできます。

モジュールをextendする
　extendを使うと、モジュール内のメソッドをそのクラスの特異メソッド（つまりクラスメソッド）にすることができます。

includeされたモジュールの有無を確認する

* クラスオブジェクトに対してinclude?メソッドを呼ぶと、引数で渡したモジュールがincludeされているかどうかがわかります。
* included_modulesメソッドを呼ぶと、includeされているモジュールの配列が返ります。

Enumerableモジュール
　配列やハッシュ、範囲（Range）など、何かしらの繰り返し処理ができるクラスにincludeされているモジュールです。
例）map   select   find   countメソッドなど

Comparableモジュール
　比較演算を可能にする（つまり値の大小を判定できるようにする）モジュールです。
例）<   <=   ==   >   >=   between?

Kernelモジュール
　KernelモジュールはObjectクラスに includeされているため、すべてのクラスはKernelモジュールのメソッドが使えるようになっている
例）puts   p   pp   print   require   loop

モジュールとインスタンス変数
　モジュール内で定義したメソッドの中でインスタンス変数を読み書きすると、include先のクラスのインスタンス変数を読み書きしたことと同じになります。

モジュールを利用した名前空間の作成

* モジュール構文の中にクラス定義を書くと「そのモジュールに属するクラス」という意味になるため、同名のクラスがあっても外側のモジュール名さえ異なっていれば名前の衝突は発生しなくなります。

* モジュールに属するクラスを参照する際は“モジュール名::クラス名”のように、::でモジュール名とクラス名を区切ります。

モジュールに特異メソッドを定義する

　includeやextendを使うとモジュールのメソッドをインスタンスメソッドやクラスメソッドとして追加することができます。しかし、場合によってはわざわざほかのクラスに組み込まなくてもモジュール単体でそのメソッドを呼び出したい、と思うケースがあります。こういう場合はモジュール自身に特異メソッドを定義すれば、直接“モジュール名.メソッド名”という形でそのメソッドを呼び出すことができます。

● module_functionメソッド
　モジュールではミックスインとしても使えて、なおかつモジュールの特異メソッドとしても使える、一石二鳥なメソッドを定義することもできます。両方で使えるメソッドを定義する場合はmodule_functionメソッドを使って、対象のメソッド名を指定します。

モジュールに定数を定義する
　クラスに定数を定義できたように、モジュールにも定数を定義することができます。定義のしかたや参照のしかたはクラスの場合と同じです。



#Ruby Silver 試験ポイントまとめ(自分用)
  自分用メモで汚いですが間違えやすいところをまとめ

Ruby 2.0以降では、デフォルトのスクリプトエンコーディングはUTF-8

例外処理について

Rescue 節で省略するとstandard error とそのサブクラスを拾う
Ensure節は必ず実行される
raiseメソッドは引数を指定していなければ、RuntimeError例外を発生

八進数表記

0から始まるもの
Puts 090 などでエラー
演算子の優先順位は*よりも**が高い

可変長変数

*a などで宣言
任意の数の引数が取れ、aに配列が格納される
Initializeメソッドは何回でも読み出され書き直される

Super の記述場所は任意の位置でおｋ

外部モジュール読み込みについて

数学PIなどをしようする場合Mathモジュールを読みこむ必要がある
読み込み方法例
Include Math
Math::PI
クラス拡張のメソッドより特異メソッドが優先して実行される

メモ：https://tamata78.hatenablog.com/entry/2015/08/07/200454