# Ruby


## Rubyに関する基礎知識

識別子と予約語
以下の予約語は識別子として使うことができない

putsメソッド、printメソッド、pメソッド、ppメソッド

その他
* 定数はメソッド内で定義できない
* foo(*arr)  引数に配列を渡す
* foo(**hash)  引数にハッシュ(キーワード引数)を渡す

参照

* a.equal?(b)  オブジェクトIDが一致するか
* a.eql?(b)  オブジェクトの値が一致するか
※ 1.eql?(1.0) => false


## 演算子

&&や||の戻り値と評価を終了するタイミング
* 式の左側から評価
* 式全体の真または偽が確定すると式の評価を終了
* 最後に評価した式の値を返す

論理演算子の応用
* item = ary&.first  arrがnilでない時のみ firstメソッドを呼び出す
* var || = 1  varがnilの時のみ1を代入

優先順位
* (*)(/)(%) > (+) > (-) > (&&) > (||) > (==) > (=)


## 数列

基数指示子を用いた整数リテラル
- 0b○○  2進数
- 0d○○  10進数
- 0o○○  8進数
- 0x○○  16進数

四則演算
* x.div(y)  割算
* x.quo(y)  割算 ※Rationalに変換
* x.modulo(y)  余り
* x.remainder(y)  余り※xの符号に一致
* x.divmod(y)  割引  ※商と余りを配列で返す

変換
* to_f  Flootに変換
* to_r  Rationに変換
* to_i  小数切り捨て
* round  小数四捨五入
* floor  小数切り捨て

ランダム値
* Random.rand(n)  0〜nまでの整数をランダムで1つ生成
* secureRandom.base64  英数字記号を生成


## 配列

配列作成
- Array.new(x, y)  xが要素数、yが格納される値  ※Array.new(x){y}でも可
- Array[a]
- %w(a)または%w|a|
- %i(a)  ※要素がシンボルになる
- to_a  ※ハッシュ、範囲オブジェクトを配列に変換

要素の参照
* a.at(n)  n番目の要素を取り出す
  * a.slice(n)
* a.values_at(n1, n2, …)  とびとびに要素を取り出す&配列を返す

要素の変更、追加、削除
* a.push(item)  末尾に挿入
* a.pop  末尾を取り除く※破壊的
* a.unshift(item)  先頭に挿入
* a.shift  先頭を取り除く※破壊的
* a.concat(b)  連結  ※破壊的
* a.compact  nilを削除 ※非破壊的
* a.delete(x)  要素xを削除  ※破壊的
* a.delete_at(x)  添字x番目を削除  ※破壊的
* a.delete_if  {|item| …}  aからitemを取り除く  ※破壊的
  * a.reject!

ブロックを使う配列メソッド
* a.collect {|item|…}  別の要素に置き換える
  * a.map {|item| …}
* a.detect {|item| …}  aからitemと一致した先頭の要素を返す
  * a.find {|item| …}
* a.select {|item| …}  aからitemと一致した要素を全て返す
  * a.find_all {|item| …}
* a.each_slice(n)  aからn個ずつブロックに渡す
* a.partition {|item| …}  真と偽に分けて別々の配列を作成
* a.inject(x) {|i, item| …}  要素を注入し処理(合算)
  ※ x(初期値)を入れる→ iに代入
  ※ xを省略 → aの先頭をiに代入
  ※ xに演算子を入れる → 指定した演算でaを計算(ブロックNG)
* a.sum(x) 要素の合計を算出  ※引数で0以外の初期値を指定することも可

その他
* a.fill(value)  valueに置き換える
* a.flatten  平坦化  ※非破壊的
* a.zip(b)  2つの配列をつなげる
* a.product([b])  レシーバの配列と引数の配列それぞれから要素を1 個ずつとって新しい配列を作成
* a.join(x)  配列の要素を連結して1つの文字列にする
* a.chars(str)  文字列を1文字ずつ配列の要素に分解する
* *[a]  配列を展開
* *”a”  配列として代入


## 文字列

文字列作成
- %Q  式展開あり
- %q  式展開なし
- %のみでも可

ヒアドキュメント作成
* << “終了の記号”
  ※ 末尾の区切文字は行頭にする
  ※ 終了記号を””で囲むと式展開
  ※ 空白も認識される
  ※ <<-  区切文字行頭の空白が無視
  ※ <<~  すべての行の空白を無視

要素の変更、追加、削除
* s.chop  末尾を削除
* s.chomp  末尾を削除(改行文字のみ)
* s.delete(str)   文字列strを削除  ※非破壊的
* s.strip  先頭末尾の空白|改行削除  ※非破壊的
* s.swapcase  大文字⇄小文字を変換
* s.tr(a, b)  aと一致した文字をbに置き換える

その他
* s.index(str)  sから一致した文字列の先頭添字を返す
  * s.rindex(str)


## シンボル

シンボル作成
- to_s  文字列をシンボルに変換
- %s(x)
- %i(x)  ※シンボル値の配列作成


## ハッシュ

ハッシュ作成
- Hash.new(a)  デフォルト値aを設定
- Hash[]  ※空はNG
- to_h  ※配列オブジェクトに有効

要素の参照
* h.fetch(a)  キーaに対応する値bを取得
* h.keys  登録されたkey取得
* h.values  登録されたvalue取得
* h.values_at(key)  とびとびでキーに対応する要素を取り出す
* h.key?(key)  keyがあればtrue
  * h.has_key?(key)
  * h.include?(key)
  * h.member?(key)
* h.value?(value)  valueがあればtrue
  * h.has_value?(value)

要素の変更、追加、削除
* h.store(a,b)  キーaと値bを登録
* h.delete(key)  キーを削除  ※破壊的
* h.clear  ハッシュを空にする  ※破壊的
* h1.merge(h2)  2つのハッシュを合体　※非破壊的
  * h1.update(h2)  ※破壊的


## 正規表現

* .  任意の1文字にマッチ
* \s  改行や空白にマッチ
* \w  英数字にマッチ
* \A  文字列の先頭にマッチ
* \z  文字列の末尾にマッチ
* [^○]  ○以外の文字にマッチ
* scan  正規表現で()を使うと、マッチした部分を配列で返す
* i  英字大文字小文字を区別しない
* scan(\(n)\)  正規表現内で()がある場合はマッチ内容を配列で返す

　正規表現とは、ある一定の規則で並んでいる文字列を検出するための技術のことです。
　正規表現オブジェクトは次のようにスラッシュでパターンを囲んで作成します（正規表現リテラル）

例）  /正規表現/
￼
* []・・・[]内のいずれか1文字を表すメタ文字
* {数字}・・・「直前のパターンを数字の分だけ繰り返す」メタ文字
* +・・・「直前の文字が1回以上連続する」ということを意味するメタ文字
* ＊・・・「直前の文字が0個以上」を表すメタ文字
* ?・・・「直前の文字を0もしくは1回繰り返す」メタ文字
* \w・・・「アルファベットの大文字or小文字、または数字、またはアンダースコアのいずれか1文字」の意味
* \d・・・「10進数の数字にいずれか1文字」の意味


正規表現の文法
　文字列と正規表現のマッチを試みる方法はいくつかあります。その1つが「=~」です。=~を使うと、正規表現がマッチした場合は文字列中の最初にマッチした位置（0以上の数値）が返り、マッチしなかった場合はnilが返ります。


キャプチャ機能
　丸括弧()で括ってグループ化したパターンに対してマッチングを行うと、マッチした文字列を抜き出して後で使うことができるようになります。

● MatchData
* matchメソッドによるパターンマッチの場合、MatchDataオブジェクトが返ります。マッチしない場合はnilが返ります。
* MatchDataは[]を使って正規表現の処理結果を取得できます。
例）
 text = '私の誕生日は1977年7月17日です'
 m = /(\d+)年(\d+)月(\d+)日/.match(text)

　 # マッチした部分全体を取得する
 m[0]    #=> "1977年7月17日"

　 # キャプチャの1番目を取得する
 m[1]    #=> "1977"

　 # キャプチャの2番目から2個取得する
 m[2, 2] #=> ["7", "17"]

　 # 最後のキャプチャを取得する
 m[-1]   #=> "17"

● キャプチャに名前を付ける
* キャプチャには(?<name>)というメタ文字を使って名前を付けることができます。
例）  (?<year>\d+)年(?<month>\d+)月(?<day>\d+)日
* 左辺に正規表現リテラルを、右辺に文字列を置いて=~演算子を使うと、キャプチャの名前がそのままローカル変数に割り当てられるのです。

● 組み込み変数でマッチの結果を取得する
　$で始まる特殊な変数（組み込み変数）が存在します。=~演算子やmatchメソッドを使うと、組み込み変数にマッチした結果が代入されます。

例）# マッチした部分全体を取得する
 $& #=> "1977年7月17日"

例）# 1番目～3番目のキャプチャを取得する
 $1 #=> "1977"
 $2 #=> "7"
 $3 #=> "17"

例） # 最後のキャプチャ文字列を取得する
 $+ #=> "17"

正規表現と組み合わせると便利なStringクラスのメソッド

● scanメソッド
　引数で渡した正規表現にマッチする部分を配列に入れて返します。

● []、slice、slice!メソッド
　正規表現を渡すと、文字列から正規表現にマッチした部分を抜き出します。
※ マッチする部分が複数ある場合は、最初にマッチした文字列が返ります
※ キャプチャを使うと第2引数で何番目のキャプチャを取得するか指定できます。
例）
text = '誕生日は1977年7月17日です'
　 # 第2引数を指定して3番目のキャプチャを取得する
text[/(\d+)年(\d+)月(\d+)日/, 3] #=> "17"

● splitメソッド
　正規表現を渡すと、マッチした文字列を区切り文字にして文字列を分解し、配列として返します。

● gsub、gsub!メソッド
　第1引数の正規表現にマッチした文字列を第2引数の文字列で置き換えます。
※ 第2引数にハッシュを渡して、変換のルールを指定することもできます。

正規表現オブジェクトを作成するさまざまな方法

1. Regexp.newの引数にパターンの文字列を渡す方法
2. %rを使う方法（%記法）

正規表現オブジェクト作成時のオプション

● mオプション
　任意の文字を表すドット（.）が改行文字にもマッチするようになります。

● xオプション
　空白文字（半角スペースや改行文字）が無視される

Regexp.last_matchでマッチの結果を取得する
　=~演算子などで最後にマッチした結果をMatchDataオブジェクトとして取得できます。



## 例外処理

* rescue  例外発生時の処理
※ 例外クラスを指定しない場合はstandarderrorとサブクラスを補足
* rescue => e  例外情報取得
    * $!  最後に発生した例外情報取得
    * $@  最後に発生した例外情報取得
* ensure~end  例外有無に関わらず実行される処理
* retry  began節からやり直し
* raise  意図的に例外発生
    * raise message RuntimeError&メッセージを発生
    * raise Exception  指定した例外クラスを発生
    * raise Exception, message  指定した例外クラスとメッセージを発生

例外クラス
- RuntimeError  特定の例外クラスには該当しないエラー
- syntax error  構文エラー
- NameError/NoMethodError  変数またはメソッドが存在しない  ※NameErrorがスーパークラス
- TypeError  別のオブジェクトが渡されている
- ZeroDivisionError  整数を0で割る


## IO

* STDIN  組み込み定数
* $stdin
* STDOUT  組み込み定数
* $stdout
* io = File.open(file[, mode[, perm]][, opt]
    * r  読み込み専用
    * r+  読み込み/書き込み用
    * w  書き込み専用(新規作成)
    * w+  読み込み/書き込み用
    * a  追加書き込み用
    * a+  読み込み/追加書き込み
* file.close
* File.read(file,[, length[, offset]]  lengthは読み込むサイズ、offsetには先頭何バイト目から読み込むか
* File.binread(file,[, length[, offset]]
* File.write(file, date[, length[, offset]]
* io.gets  1行ずつ読み込む
    * io.each
    * io.each_line
* io.readline  改行区切りで配列として返す
* io.each_char 1文字ずつ読み込む
* io.getc 1文字だけ読み込む
* io.read(size)  長さを指定して読み込む
* io.puts
* io.pos  ファイルポインタの現在位置取得
* io.seek(offset, whence)  ファイルポインタを移動する
    * SEEK_SET  offsetの位置に移動する
    * SEEK_CUR  offsetを現在の相対位置と見なし移動する
    * SEEK_END  offsetをファイル末尾からの相対位置とし移動する
* io.rewind  ポインタを先頭に戻す


## File

* File.rename(“before”, “after”) ファイル名変更/ファイル移動  ※Fileクラスのみ
* File.delete(file) ファイル削除
    * File.unlink(file)
* Dir.pwd  ※Dirクラスのみ
* Dir.chdir(dir)  ※Dirクラスのみ
* Dir.open(path)  フォルダ内容を読む
* Dir.close
* dir.read
* Dir.mkdir(path)  新しいフォルダを作成
* Dir.rmdir(path)  フォルダを削除
    * Dir.delete
* Dir.home
* File.chmod(mode, path)  ファイルpathの許可モード変更
* File.chown(owner, group, path)ファイルpathの所有者を変更
* File.basename(path)  拡張子を除いたファイル名を取得
* File.dirname(path)  ディレクトリ名を取得
* File.extname(path)  拡張子を取得
* File.split(path)  ディレクトリ名とファイル名に分解→配列で返す
* File.join(name1, name2…)

* Time.new = Time.now
* t.year
* t.month
* t.day
* t.strftime(format) = t.to_s
    * %Y  西暦4桁
    * %y  西暦下2桁
    * %M  分
    * %m  月を表す数字
    * %D  %m/%d/%yと同じ
    * %x  %Dと同じ
    * %F  %Y-%m-%dと同じ
* Time.parse(str)  文字列から時間に変化する
    * Time.strptime(str,format)
* Date.parse(str)  文字列から時間に変化する
    * Date.strptime(str, format)
* to_time
* to_date




keysメソッド
hashからkeyを取り出す

> x = { "ruby"=>1 , "php"=>2 , "java"=>3 }
=> {"ruby"=>1, "php"=>2, "java"=>3}
> x.keys
=> ["ruby", "php", "java"]
valuesメソッド
hashからkeyを取り出す

> x = { "ruby"=>1 , "php"=>2 , "java"=>3 }
=> {"ruby"=>1, "php"=>2, "java"=>3}
> x.values
=> [1, 2, 3]
storeメソッド
hashにkeyと値を追加する

> x = { "ruby"=>1 , "php"=>2 , "java"=>3 }
=> {"ruby"=>1, "php"=>2, "java"=>3}
> x.store("python",4)
=> 4
> x
=> {"ruby"=>1, "php"=>2, "java"=>3, "python"=>4}
selectメソッド
指定条件に合致するKeyと値を表示する

> x = { "ruby"=>1 , "php"=>2 , "java"=>3 }
=> {"ruby"=>1, "php"=>2, "java"=>3}
> x.select {|k, v| v >= 3 }
=> {"java"=>3}

#以下も同様
 x.select do |k, v|
  v >= 3
 end
to_aメソッド
レシーバー自身を返すメソッド。
範囲オブジェクトを、配列に変換する際に使用する場合が多い。
配列を２次元配列として返す。

> X = 1..10
=> 1..10
> X.to_a
=> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

> x = { "ruby"=>1 , "php"=>2 , "java"=>3 }
=> {"ruby"=>1, "php"=>2, "java"=>3}
> x.to_a
=> [["ruby", 1], ["php", 2], ["java", 3]]
to_hメソッド
２次元配列をハッシュ化する。
レシーバを[key, value] のペアの配列として、Hash を返す。

> x = [ ["ruby",1] , ["php",2] , ["java",3] ]
=> [["ruby", 1], ["php", 2], ["java", 3]]
> x.to_h
=> {"ruby"=>1, "php"=>2, "java"=>3}

array = User.all
array.map { |user| [user.id, user.name] }.to_h
> {1=>"sample", 2=>"sampleb", 3=>"Guest User", 4=>"test user"}

to_iメソッド
integerクラス(整数)に変換する

> x = "123"
=> "123"
> x.to_i
=> 123
*メソッド
四則演算の掛け算をするメソッド
Integerクラスの *メソッドは引数にIntegerクラスのインスタンスを与えなければいけない。
つまり右辺に整数を書く必要がある。

puts "*" * 4
> ****
=> nil

puts 4 * "*"
TypeError: String can't be coerced into Integer
from (pry):18:in `*'
compactメソッド
配列のnill要素を削除する

> x = ["ruby","php",nil,"java",nil]
=> ["ruby", "php", nil, "java", nil]
> x.compact
=> ["ruby", "php", "java"]
uniqメソッド
配列内の重複要素を削除する

> x = ["ruby","php",nil,"java",nil,"ruby","java"]
=> ["ruby", "php", nil, "java", nil, "ruby", "java"]
> x.uniq
=> ["ruby", "php", nil, "java"]
joinメソッド
配列の要素を結合して一つの文字列にする
配列の要素が配列であった場合平坦化する

#結合
> x = ["ruby", "php", "java"]
=> ["ruby", "php", "java"]
> x.join
=> "rubyphpjava"

#引数で区切る
> x = ["ruby", "php", "java"]
=> ["ruby", "php", "java"]
> x.join(",")
=> "ruby,php,java"

#平坦化
> x = [["ruby","php"],["python","java"]]
=> [["ruby", "php"], ["python", "java"]]
> x.join(" ")
=> "ruby php python java"
pushメソッド
配列の末尾に要素を連結する

> x = ["ruby", "php", "java"]
=> ["ruby", "php", "java"]
> x.push("python")
=> ["ruby", "php", "java", "python"]
popメソッド
配列の末尾の要素を削除する
削除された要素は、popメソッドの戻り値として返る

> x = ["ruby", "php", "java"]
=> ["ruby", "php", "java"]
> x.pop
=> "java"
> x
=> ["ruby", "php"]

#引数に代入した数字の分要素を削除
> x = ["ruby", "php", "java"]
=> ["ruby", "php", "java"]
> x.pop(2)
=> ["php", "java"]
> x
=> ["ruby"]
shiftメソッド
配列の先頭の要素を削除
配列の先頭の要素を取り出す

> x = ["ruby", "php", "java"]
=> ["ruby", "php", "java"]
> x.shift
=> "ruby"
> x
=> ["php", "java"]

#引数に代入した数字の分要素を削除
> x = ["ruby", "php", "java"]
=> ["ruby", "php", "java"]
> x.shift(2)
=> ["ruby", "php"]
> x
=> ["java"]

#要素を取り出す(popメソッドでも要素を取り出すことができる)
> x = ["ruby", "php", "java"]
=> ["ruby", "php", "java"]
> X = x.shift
=> "ruby"
> X
=> "ruby"
unshiftメソッド
配列の先頭に要素を挿入する

> x = ["ruby", "php", "java"]
=> ["ruby", "php", "java"]
> x.unshift("python")
=> ["python", "ruby", "php", "java"]
splitメソッド
指定した区切り文字で対象となる文字列を分割して配列にする

> x = "ruby, php, java"
=> "ruby, php, java"
> x.split(',')
=> ["ruby", " php", "java"]

#引数で指定しないと一文字ずつ配列にする
> x = "ruby"
=> "ruby"
> x.split('')
=>["r","u","b","y"]
sliceメソッド
配列や文字列から指定の要素を切り出す

> x = ["ruby", "php", "java"]
=> ["ruby", "php", "java"]
> x.slice(0)
=> "ruby"

#「指定位置から指定の数」の要素をまとめて取りだすこともできる
#第一引数でインデックスを指定して第二引数で要素数を指定する
> x.slice(0,2)
=>["ruby", "php"]
sortメソッド
配列の順番を並び替える

> x = [3,5,1,25,8]
=> [3,5,1,25,8]
> x.sort
=> [1, 3, 5, 8, 25]
#reverseメソッドで降順も可能
> x.sort.reverse
=> [25, 8, 5, 3, 1]
pluckメソッド
引数に指定したカラムの配列を返す(Railsのメソッド)

#Userモデルのnameカラムに　"Itiro"　"jiro"　"taro"　が入っている場合
=> User.pluck(:name)
=> ["Itiro","jiro","taro",]
chompメソッド
Stringクラスのメソッドで、文字列の末尾から改行コードを取り除いた文字列を返す

> a = "ruby\n"
=> "ruby\n"
> p a
"ruby\n"
=> "ruby\n"
> p a.chomp
"ruby"
=> "ruby"
#改行コードのない文字列に対して破壊的メソッドを使うとnilが返る
> a.chomp!
=> "ruby"
> a.chomp!
=> nil
transposeメソッド
Arrayクラスのメソッドで、行列の転置(行と列の入れ換え)を行う。

key = [1, 2, 3]
value = ["gold", "silver", "bronze"]
ary = [key, value].transpose
p ary
=>[[1, "gold"], [2, "Silver"], [3, "Bronze"]]


p [[1,2],
   [3,4],
   [5,6]].transpose
 => [[1, 3, 5], [2, 4, 6]]


 Ruby Silver 試験ポイントまとめ(自分用)
自分用メモで汚いですが間違えやすいところをまとめてますぜひ

Ruby 2.0以降では、デフォルトのスクリプトエンコーディングはUTF-8
Hash#eachのブロックパラメータはArray。
Hash#size はhashの要素の数を返す
Enumerable#select selfからブロックの条件に該当する要素を集めて返す。
Enumerable#find selfからブロックの条件に該当する最初の要素を返す。
Array#delete selfから引数の要素を削除。削除した要素を返す。破壊的メソッド。

例外処理について

Rescue 節で省略するとstandard error とそのサブクラスを拾う
Ensure節は必ず実行される
raiseメソッドは引数を指定していなければ、RuntimeError例外を発生
八進数表記

0から始まるもの
Puts 090 などでエラー
演算子の優先順位は*よりも**が高い

Ruby定数は大文字で始める

変更可能だが警告が出る
Ruby変数名

１文字目はアルファベット小文字か_で始める必要がある。
２文字目以降はアルファベットもしくは数字を使用
可変長変数

*a などで宣言
任意の数の引数が取れ、aに配列が格納される
Initializeメソッドは何回でも読み出され書き直される

Super の記述場所は任意の位置でおｋ

外部モジュール読み込みについて

数学PIなどをしようする場合Mathモジュールを読みこむ必要がある
読み込み方法例
Include Math
Math::PI
クラス拡張のメソッドより特異メソッドが優先して実行される

.. , … 演算子について

a = [1,2,3,4]
a[0..3] => [1,2,3,4]
a[0..-1] => [1,2,3,4]
a[0,3] => [1,2,3]
find_all == select

map == collect

正規表現記号

*は直前の文字列の０回以上の繰り返しを表す
Iオプションで大文字と小文字の区別しない
. は任意の文字を表す
{m}は直前の正規表現のm回の繰り返しを意味
Mオプションで.が改行にもマッチする
\d+などの+は連続を表す
Matchは一度しか行わない
Scanは繰り返し行われる
\wは単語構成文字の省略記号
65を”A”にしたい時

65.chr
逆は”A”.ord
ヒアドキュメント

<<-識別子' のように-' を付けて書くことで終端行をインデントすることは可能
通常は空白を開けるとエラー
Chompメソッドで\r\n全て消す

chopメソッドで末尾の文字を消す

IO#rewindはファイルポインターを先頭に移動する

Splitメソッドは引数で特定の文字列を区切り文字として指定できる。また第二引数で生成される配列の個数を指定することができる。

“0-5”は範囲指定になるが、”8-”では範囲指定にならず8と-を削除します

eql は 文字列が同じ場合true

equal は　オブジェクトが同じかどうかを見る

inject はブロックに要素を割り当てる…|i,j|

IO

IO#getsとIO#readlineはファイルオブジェクトから一行読み込んで、読み込みに成功した時にはその文字列を返す。
IO#getsとIO#readlineの違いはEOFに到達した時の振る舞いのみ。IO#getsはnil, IO#readlineはEOFErrorを返す
foo = [1,2,3]
bar = foo
p foo === bar # => true
Module Foo
  def foo           //インスタンスメソッドとして定義
    puts("foo")
  end
end

Class Bar
  extend Foo        //FooモジュールのインスタンスメソッドをBarクラスの特異メソッドとして定義
end

Bar.foo  #=> foo  という使い方ができる
::Fooのような::演算子から始まる定数は、トップレベルで定義されている定数

slice!はスライス後を参照している

ファイルの末尾(EOF)への反応の仕方

getsの場合、nilが帰る
Readlineの場合、EOFError例外が発生する
File#mtimeメソッドは更新が保存されるがFile::Stat#mtimeメソッドは更新が保存されない

File::Statクラスはnewメソッドのみクラスメソッド
ファイル名と拡張子が".“で区切られているファイル名から任意の拡張子を取り除く時に、第2引数として”.*"を指定してFile.basenameを呼び出します

"%2d%s"の"%2d"は出力したい数値が2桁より少なければ、空白スペースを入れるようにする指定