# クラス

initializeメソッド
　クラスからオブジェクトを作成する場合はnewメソッドを使います。このときに呼ばれるのがinitializeメソッドです。initializeメソッドに引数を付けると、newメソッドを呼ぶときにも引数が必要になります。

インスタンス変数とアクセサメソッド

* インスタンス変数
インスタンス変数とは同じインスタンス（同じオブジェクト）の内部で共有される変数です。インスタンス変数はクラスの外部から参照することができません

* nameメソッドのように値を読み出すメソッドを「ゲッターメソッド」、name=メソッドのように値を書き込むメソッドを「セッターメソッド」と呼びます。また、ゲッターメソッドとセッターメソッドを総称して、「アクセサメソッド」と呼びます。

* 単純にインスタンス変数の内容を外部から読み書きするのであれば、attr_accessorというメソッドを使ってアクセスメソッドの定義を省略することができます
例）attr_accessor :name

* インスタンス変数の内容を読み取り専用にしたい場合はattr_accessorの代わりにattr_readerメソッドを使います
例）attr_reader :name

定数
　定数はクラスの外部から直接参照することも可能です。クラスの外部から定数を参照する場合は次のような構文を使います。

クラス名::定数名



Rubyのクラスメソッドとインスタンスメソッドの違い

■ クラスメソッド・・・クラスオブジェクトから実行可能なメソッド

class Hoge
  def self.hoge または  class << self
    puts "hoge"
  end
end
Hoge.hoge # => hoge
※   クラスメソッドを使う場合、クラス直下のメソッドにself.を設定する

■ インスタンスメソッド・・・インスタンスオブジェクトから実行可能なメソッド

class Hoge
  def hoge
    puts "hoge"
  end
end
Hoge.new.hoge # => hoge

1. インスタンスメソッドからインスタンスメソッドを呼び出す
　インスタンスメソッドの中からインスタンスメソッドを呼び出すときはレシーバを省略できます

class User
  def greeting
    ①User.name          # クラスを明示する
    ②self.class.name # self.class はUserとなる
    ③class.name        # selfは省略できる
  end

  def self.name
    '太郎'
  end
end

2. クラスメソッドからインスタンスメソッドを呼び出す
　インスタンスメソッドを呼び出すにはレシーバをインスタンスにする必要があるので以下のようになります。

class User
  def self.greeting
    ①User.new.name # クラスのインスタンスを生成してからnameメソッドを呼び出す
    ②self.new.name  # Userをselfにした
    ③new.name          # selfは省略できる
  end

  def name
    '太郎'
  end
end

3. クラスメソッドからクラスメソッドを呼び出す
　クラスメソッド内のselfはクラス自身なのでレシーバを省略して普通にメソッドを呼び出せます。


クラスの継承

* DVDクラスがProductクラスを継承するとき、ProductクラスのことをDVDクラスの「スーパークラス（または親クラス）」と呼びます。逆にProductクラスから見ると、DVDクラスはProductクラスの「サブクラス（または子クラス）」と呼びます。

* サブクラスはスーパークラスの性質を特化したもので、反対にスーパークラスはサブクラスの性質を汎化したものである、という関係もなりたちます。

* クラスの継承が適切かどうかを判断する方法の1つは、 「サブクラスはスーパークラスの一種である（サブクラス is a スーパークラス）」 と声に出して読んだときに違和感がないか確かめることです。

● オブジェクトのクラスを確認する方法

1. user.class #=> User
2. user.instance_of?(User)   #=> true

● 継承関係（is-a関係にあるかどうか）を含めて確認する方法
* user.is_a?(Object)        #=> true

● superでスーパークラスのメソッドを呼び出す
　superを使うとスーパークラスの同名メソッドを呼び出すことができます。
　スーパークラスとサブクラスで引数の数が同じだった場合は、引数なしのsuperを呼ぶだけで自分に渡された引数をすべてスーパークラスに引き渡すことができます

● メソッドのオーバーライド
　サブクラスではスーパークラスと同名のメソッドを定義することで、スーパークラスの処理を上書きすることができます。


特異メソッド
　特定のオブジェクトにだけ紐付くメソッドのことを特異メソッドと呼びます。数値（IntegerとFloat）やシンボルなど、特異メソッドを定義できないオブジェクトも存在します。
　※クラスメソッドは特異メソッドの一種です。

ダックタイピング
　オブジェクトのクラスが何であろうとそのメソッドが呼び出せれば良しとするプログラミングスタイルのことを「ダックタイピング（duck typing）」と呼びます。


モジュール

* モジュールからインスタンスを作成することはできない。
* ほかのモジュールやクラスを継承することはできない。

モジュールをクラスにincludeする
　モジュールをクラスにincludeして機能を追加することをミックスインと言います。また、1つのクラスに複数のモジュールをミックスインすることもできます。

モジュールをextendする
　extendを使うと、モジュール内のメソッドをそのクラスの特異メソッド（つまりクラスメソッド）にすることができます。

includeされたモジュールの有無を確認する

* クラスオブジェクトに対してinclude?メソッドを呼ぶと、引数で渡したモジュールがincludeされているかどうかがわかります。
* included_modulesメソッドを呼ぶと、includeされているモジュールの配列が返ります。

Enumerableモジュール
　配列やハッシュ、範囲（Range）など、何かしらの繰り返し処理ができるクラスにincludeされているモジュールです。
例）map   select   find   countメソッドなど

Comparableモジュール
　比較演算を可能にする（つまり値の大小を判定できるようにする）モジュールです。
例）<   <=   ==   >   >=   between?

Kernelモジュール
　KernelモジュールはObjectクラスに includeされているため、すべてのクラスはKernelモジュールのメソッドが使えるようになっている
例）puts   p   pp   print   require   loop

モジュールとインスタンス変数
　モジュール内で定義したメソッドの中でインスタンス変数を読み書きすると、include先のクラスのインスタンス変数を読み書きしたことと同じになります。

モジュールを利用した名前空間の作成

* モジュール構文の中にクラス定義を書くと「そのモジュールに属するクラス」という意味になるため、同名のクラスがあっても外側のモジュール名さえ異なっていれば名前の衝突は発生しなくなります。

* モジュールに属するクラスを参照する際は“モジュール名::クラス名”のように、::でモジュール名とクラス名を区切ります。

モジュールに特異メソッドを定義する

　includeやextendを使うとモジュールのメソッドをインスタンスメソッドやクラスメソッドとして追加することができます。しかし、場合によってはわざわざほかのクラスに組み込まなくてもモジュール単体でそのメソッドを呼び出したい、と思うケースがあります。こういう場合はモジュール自身に特異メソッドを定義すれば、直接“モジュール名.メソッド名”という形でそのメソッドを呼び出すことができます。

● module_functionメソッド
　モジュールではミックスインとしても使えて、なおかつモジュールの特異メソッドとしても使える、一石二鳥なメソッドを定義することもできます。両方で使えるメソッドを定義する場合はmodule_functionメソッドを使って、対象のメソッド名を指定します。

モジュールに定数を定義する
　クラスに定数を定義できたように、モジュールにも定数を定義することができます。定義のしかたや参照のしかたはクラスの場合と同じです。


例外処理

例外を捕捉して処理を続行する場合
　何らかの理由で例外が発生してもプログラムを続行したい場合は、例外処理を明示的に書くことでプログラムを続行させることが可能です。
例）
begin
    # 例外が起きうる処理
 rescue
    # 例外が発生した場合の処理
 end

例外オブジェクトから情報を取得する
　Rubyでは発生した例外自身もオブジェクトになっています。そのため例外オブジェクトのメソッドを呼び出すことで、発生した例外に関する情報を取得することができます。

● messageメソッド
　例外発生時のエラーメッセージを返します。

● backtraceメソッド
　バックトレース情報（つまりメソッドの呼び出し履歴）を配列にして返します。

クラスを指定して捕捉する例外を限定する
　例外には多くの種類があり、その種類ごとにクラスが異なります。次のような構文を使って例外のクラスを指定すると、例外オブジェクトのクラスが一致した場合のみ、例外を捕捉することができます。

begin
    # 例外が起きうる処理
 rescue 捕捉したい例外クラス
    # 例外が発生した場合の処理
 end

例外発生時にもう一度処理をやりなおすretry
　ネットワークエラーのように一時的に発生している問題が例外の原因であれば、何度かやりなおすことで正常に実行できる可能性があります。そんな場合はrescue節でretry文を実行すると、begin節の最初からやりなおすことができます。

意図的に例外を発生させる
　コードの中で意図的に例外を発生させることができます。例外を発生させる場合はraiseメソッドを使います。

● raiseメソッド
　文字列を渡すと、その文字列がエラーメッセージになる。
※ raiseメソッドに文字列だけを渡したときはRuntimeErrorクラスの例外が発生します。

例外処理についてもっと詳しく
● ensure
　例外処理を入れた場合、例外が発生してもしなくても必ず実行したい処理が出てくる場合があります。そんな場合は例外処理にensure節を加えることで必ず実行される処理を書くことができます。

● $!と$@に格納される例外情報
　Rubyでは最後に発生した例外は組み込み変数の$!に格納されます。また、バックトレース情報は$@に格納されます。